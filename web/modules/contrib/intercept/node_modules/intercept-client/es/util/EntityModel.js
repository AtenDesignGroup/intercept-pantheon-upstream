var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import findKey from 'lodash/findKey';
import keys from 'lodash/keys';
import pickBy from 'lodash/pickBy';
import uuidv4 from 'uuid/v4';

import { JsonApiSchema, JsonApiModel } from './JsonApiModel';
import Registrar from './Registrar';

export var modelRegistrar = new Registrar('entityManagers');

export function loadEntity(resource, id, state) {
  // if (!state.hasOwnProperty(resource)) {
  //   logger.log(new Error(`Tried to load an entity from a resource, ${resource}, that does not exist.`));
  //   return null;
  // }
  //
  // const entity = state[resource].items[uuid];
  //
  // if (!entity) {
  //   logger.log(new Error(`Tried to load a ${resource} entity, ${uuid}, that does not exist.`));
  //   return null;
  // }
  //
  // return entity;
  return state[resource].items[id];
}

export function loadEntityFromState(state) {
  return function (resource, id) {
    return loadEntity(resource, id, state);
  };
}

/**
 * An EntityModel is used to manage the back and forth transformation between
 *  JSON_API structured resources and locally stored entity objects.
 *  EntityModel instances are created on a per resource type basis.
 *
 * @type {EntityModel}
 */
export var EntityModel = function () {
  /**
   * Entity Manager constructor
   * @param  {String} type    Drupal entity type. ex. 'node', 'taxonomy_term'
   * @param  {String} bundle  Drupal bundle type. ex. 'article', 'tags'
   * @param  {Object} schema  Schema definition describing how fields map to JSON_API
   */
  function EntityModel(type, bundle, schema) {
    _classCallCheck(this, EntityModel);

    var resource = type + '--' + bundle;
    this.type = type;
    this.bundle = bundle;
    this.resource = resource; // JSON_API resource type
    this.schema = schema;
    this.jsonApiSchema = new JsonApiSchema(resource, schema);
    this.model = new JsonApiModel(this.jsonApiSchema);
    this.getDependentFields = this.getDependentFields.bind(this);
    this.dependentFields = this.getDependentFields();
    this.getFields = this.getFields.bind(this);
    modelRegistrar.register(resource, this);
  }

  /**
   * Create a new entity POJO to store data and state.
   * @param  {Object} data Initial entity data fields.
   * @return {Object}      Standard entity formatted data.
   */


  _createClass(EntityModel, [{
    key: 'getDependentUuids',


    /**
     * Returns a flat array of dependent entity uuids
     * @params
     */
    value: function getDependentUuids(id, state) {
      var dependentFields = this.dependentFields,
          resource = this.resource;

      var item = loadEntityFromState(state)(resource, id);

      return dependentFields.reduce(function (acc, field) {
        return (
          // Ignore null values.
          acc.concat([].concat(item.data[field]).filter(function (i) {
            return i;
          }))
        );
      }, []);
    }

    /**
     * Returns a flat array of field names. Uses alias if available.
     * @param {boolean}
     *   If aliases should be used or the root field name.
     */

  }, {
    key: 'getFields',
    value: function getFields(useAlias) {
      var schema = this.schema;

      var fields = Object.keys(schema);
      return !useAlias ? fields : fields.map(function (field) {
        return schema[field].alias || field;
      });
    }

    /**
     * Returns a flat array of dependent field names. Uses alias if available.
     * @params
     */

  }, {
    key: 'getDependentFields',
    value: function getDependentFields() {
      var schema = this.schema;

      var dependentFields = Object.keys(schema).filter(function (field) {
        return schema[field].dependency;
      }).map(function (field) {
        return schema[field].alias || field;
      });
      return dependentFields;
    }

    /**
     * Returns an array of relationships
     */

  }, {
    key: 'getRelationships',
    value: function getRelationships() {
      return keys(pickBy(this.schema, function (o) {
        return o.type === 'relationship';
      }));
    }

    /**
     * Returns an array of relationships with their aliases.
     */

  }, {
    key: 'getRelationshipAliases',
    value: function getRelationshipAliases() {
      var _this = this;

      return this.getRelationships().map(function (r) {
        return _this.getPropertyAlias(r);
      });
    }

    /**
     * Returns a property alias if it exist.
     */

  }, {
    key: 'getPropertyAlias',
    value: function getPropertyAlias(property) {
      if (property in this.schema && 'alias' in this.schema[property]) {
        return this.schema[property].alias;
      }

      return property;
    }

    /**
     * Returns a property alias if it exist.
     */

  }, {
    key: 'getPropertyFromAlias',
    value: function getPropertyFromAlias(alias) {
      return findKey(this.schema, function (property) {
        return 'alias' in property && property.alias === alias;
      }) || alias;
    }

    /**
     * Converts JSON_API formated Entity into a plain object.
     * @param  {Object} entity JSON_API formatted object
     * @return {Object}        Plain object representation of the data.
     */

  }], [{
    key: 'create',
    value: function create(data) {
      var id = data.attributes.uuid || uuidv4();
      var mergedData = Object.assign({}, data);
      mergedData.attributes = mergedData.attributes || {};
      mergedData.attributes.uuid = id;

      return {
        id: id,
        data: mergedData,
        state: {
          saved: false, // Exists remotely.
          syncing: null, // Request sent, response not yet received
          error: null, // { status: '403', message: 'Forbidden'}
          dirty: true // Local Changes, not yet synced
        }
      };
    }
  }, {
    key: 'import',
    value: function _import(entity) {
      return entity;
    }

    /**
     * Converts plain object into a JSON_API representation based on a schema.
     * @param  {Object} entity Plain object representation of the data.
     * @return {Object}        JSON_API formatted object
     */

  }, {
    key: 'export',
    value: function _export(entity) {
      // const model = new JsonApiModel(this.jsonApiSchema);

      var data = _extends({}, entity.data);
      var ignoredAttributes = ['created', 'changed', 'nid', 'tid', 'id'];
      var ignoredRelationships = ['node_type'];

      ignoredAttributes.forEach(function (prop) {
        delete data.attributes[prop];
      });

      ignoredRelationships.forEach(function (prop) {
        delete data.relationships[prop];
      });

      return {
        data: data
      };
    }
  }]);

  return EntityModel;
}();

export default EntityModel;