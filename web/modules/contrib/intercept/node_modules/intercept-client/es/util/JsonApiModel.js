var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint no-param-reassign: ["error", { "props": false }] */
/* eslint no-return-assign: ["error", "except-parens"] */
import assign from 'lodash/assign';
import forEach from 'lodash/forEach';
import map from 'lodash/map';

export var JsonApiSchema = function () {
  function JsonApiSchema(resource, schema) {
    _classCallCheck(this, JsonApiSchema);

    this.type = resource;
    this.schema = schema;
  }

  /**
   * Sets one or more values on a model returning a new instance.
   * @param {string|object} field If a string, this is the field from the schema to set.
   *                              If an object, it's a set of field value pairs.
   * @param {string|array|onject|boolean} value The value to be set. Ignored if field is an object.
   */


  _createClass(JsonApiSchema, [{
    key: 'setValue',
    value: function setValue(field, value) {
      var newModel = new this.constructor();

      if (typeof field === 'string') {
        newModel.setField(field, value);
      } else {
        forEach(field, function (val, key) {
          newModel.setField(key, val);
        });
      }
      return assign(new this.constructor(), this, newModel);
    }

    /**
     * Sets a single field value on a model
     * @param {string} field The field from the schema to set.
     * @param {string|array|object|boolean} value The value to be set
     */

  }, {
    key: 'setField',
    value: function setField(field, value) {
      var schema = this.schema;


      if (field in schema === false) {
        return this;
      }

      switch (schema.type) {
        case 'relationship':
          this.relationships[field] = {
            data: {
              type: schema[field].ref,
              id: value
            }
          };
          break;
        default:
          this.attributes[field] = value;
      }
    }
  }]);

  return JsonApiSchema;
}();

/**
 * Get a JSON_API attribute getter for a resource.
 * @param  {Object} resource  JSON_API formatted resource.
 * @param  {String} attribute The resource attribute to get
 * @return {function} A getter for the attribute.
 */
function getAttribute(resource, attribute) {
  return function () {
    return resource._data.attributes[attribute];
  };
}

/**
 * Get a JSON_API attribute setter for a resource.
 * @param  {Object} resource  JSON_API formatted resource.
 * @param  {String} attribute The resource attribute to set
 * @return {function} A setter for the attribute.
 */
function setAttribute(resource, attribute) {
  return function (value) {
    return resource._data.attributes[attribute] = value;
  };
}

/**
 * Get a JSON_API relationship getter for a resource.
 * @param  {Object}   resource      JSON_API formatted resource.
 * @param  {String}   relationship  The resource relationship to get
 * @param  {Boolean}  multiple      Whether or nohis is a multi-value relationship
 * @return {function} A getter for the relationship.
 */
function getRelationship(resource, relationship, multiple) {
  return function () {
    if (relationship in resource._data.relationships === false) {
      return undefined;
    }

    //
    // Handle multi-value fields
    //
    if (multiple) {
      return map(resource._data.relationships[relationship].data, function (d) {
        return d ? d.id : d;
      });
    }

    //
    // Handle single value fields
    //
    return resource._data.relationships[relationship].data ? resource._data.relationships[relationship].data.id : resource._data.relationships[relationship].data;
  };
}

/**
 * Get a JSON_API relationship setter for a resource.
 * @param  {Object}   resource      JSON_API formatted resource.
 * @param  {String}   relationship  The resource relationship to set
 * @param  {Boolean}  multiple      Whether or not this is a multi-value relationship
 * @return {function} A setter for the relationship.
 */
function setRelationship(resource, relationship, type, multiple) {
  return function (value) {
    if (relationship in resource._data.relationships === false) {
      resource._data.relationships[relationship] = {};
    }

    //
    // Handle multi-value fields
    //
    if (multiple) {
      var valueArray = [].concat(value);
      return resource._data.relationships[relationship].data = map(valueArray, function (v) {
        return {
          type: type,
          id: v
        };
      });
    }

    //
    // Handle single value fields
    //
    return resource._data.relationships[relationship].data = {
      type: type,
      id: value
    };
  };
}

export var JsonApiModel = function JsonApiModel(schema) {
  var _this = this;

  _classCallCheck(this, JsonApiModel);

  this._data = {
    type: schema.type,
    attributes: {},
    relationships: {}
  };

  // Create getters and setters for each prop.
  forEach(schema.schema, function (value, key) {
    Object.defineProperty(_this, value.alias ? value.alias : key, {
      get: value.type === 'relationship' ? getRelationship(_this, key, value.multiple) : getAttribute(_this, key),
      set: value.type === 'relationship' ? setRelationship(_this, key, value.ref, value.multiple) : setAttribute(_this, key)
    });
  });
};