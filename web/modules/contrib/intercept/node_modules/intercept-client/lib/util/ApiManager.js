'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ApiManager = exports.validateLimiter = exports.writeLimiter = exports.readLimiter = exports.readFileLimiter = exports.apiRegistrar = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

// Registrar


// Logger


exports.handleValidateSuccessResponse = handleValidateSuccessResponse;
exports.handleValidateFailedResponse = handleValidateFailedResponse;
exports.handleValidateResponse = handleValidateResponse;
exports.handleFailedResponse = handleFailedResponse;
exports.processIncludes = processIncludes;
exports.handleSuccessResponse = handleSuccessResponse;
exports.handleResponse = handleResponse;
exports.handleNetworkError = handleNetworkError;
exports.dataReducer = dataReducer;
exports.apiReducer = apiReducer;

var _bottleneck = require('bottleneck');

var _bottleneck2 = _interopRequireDefault(_bottleneck);

var _v = require('uuid/v4');

var _v2 = _interopRequireDefault(_v);

var _assign4 = require('lodash/assign');

var _assign5 = _interopRequireDefault(_assign4);

var _filter = require('lodash/filter');

var _filter2 = _interopRequireDefault(_filter);

var _forEach = require('lodash/forEach');

var _forEach2 = _interopRequireDefault(_forEach);

var _groupBy = require('lodash/groupBy');

var _groupBy2 = _interopRequireDefault(_groupBy);

var _mapValues = require('lodash/mapValues');

var _mapValues2 = _interopRequireDefault(_mapValues);

var _reduce = require('lodash/reduce');

var _reduce2 = _interopRequireDefault(_reduce);

var _actions = require('./../actions');

var a = _interopRequireWildcard(_actions);

var _actionTypes = require('./../actionTypes');

var t = _interopRequireWildcard(_actionTypes);

var _exponentialBackoff = require('./exponentialBackoff');

var _exponentialBackoff2 = _interopRequireDefault(_exponentialBackoff);

var _EntityModel = require('./EntityModel');

var _Registrar = require('./Registrar');

var _Registrar2 = _interopRequireDefault(_Registrar);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var url = require('url');
var URL = require('url-parse');

var apiRegistrar = exports.apiRegistrar = new _Registrar2.default('api');

// Limit file reads to 4 per second.
var readFileLimiter = exports.readFileLimiter = new _bottleneck2.default({
  maxConcurrent: 4,
  minTime: 1000 / 4
});
// Limit reads to 6 per second.
var readLimiter = exports.readLimiter = new _bottleneck2.default({
  maxConcurrent: 6,
  minTime: 1000 / 6
});
// Limit writes to 2 at a time and 3 per second.
var writeLimiter = exports.writeLimiter = new _bottleneck2.default({
  maxConcurrent: 2,
  minTime: 1000 / 3
});
// Limit validates to 1 at a time and 3 per second.
var validateLimiter = exports.validateLimiter = new _bottleneck2.default({
  maxConcurrent: 1,
  minTime: 1000 / 3
});

/**
 * Generic fetch resolve handler.
 * @param  {Request} request The request object. https://developer.mozilla.org/en-US/docs/Web/API/Request
 * @param  {function} resolve Promise.prototype.resolve()
 * @param  {function} reject Promise.prototype.reject()
 * @return {function} A handler that takes the error object from a failed fetch.
 */
function responseHandler(request, resolve, reject) {
  return function (resp) {
    // Handle a successful response.
    if (resp.ok) {
      resolve(resp);
    } else {
      // Handle a failed response.
      switch (resp.status) {
        // Don't retry:
        //   403 - Permission denied responses.
        //   404 - Not Found.
        //   409 - Conflict.
        case 403:
        case 404:
        case 409:
          resolve(resp);
          break;
        // Retry all other responses.
        default:
          reject(new Error(resp.status.toString()));
      }
    }
  };
}

/**
 * Generic fetch rejection handler.
 * @param  {Request} request The request object. https://developer.mozilla.org/en-US/docs/Web/API/Request
 * @param  {function} resolve Promise.prototype.resolve()
 * @param  {function} reject Promise.prototype.reject()
 * @return {function} A handler that takes the error object from a failed fetch.
 */
function errorHandler(request, resolve, reject) {
  return function (err) {
    _logger2.default.log('network', 'Rejected fetch', err);
    reject(err);
  };
}

/**
 * Handles dispatching a successful API call's response.
 * @param  {Object}   resp     Response object instance.
 * @param  {Function} dispatch Redux dispatch function.
 * @param  {String}   resource Resource type
 * @param  {Object}   model  EntityManager for this resource.
 * @param  {String}   [uuid]     UUID of the resource
 */
function handleValidateSuccessResponse(resp, items, dispatch, resource) {
  return resp.json().then(function (json) {
    _logger2.default.group('validate', 'response');
    _logger2.default.log('validate', 'Validation Response: ' + resource, json);

    if (!json.states) {
      return;
    }

    var manifest = (0, _reduce2.default)(json.states, function (accumulator, remoteItem, key) {
      // Locally stored item;
      var localItem = items[key];

      if (!remoteItem.created) {
        accumulator.notSaved.push(key);
      } else if (parseInt(localItem.data.changed, 10) !== parseInt(remoteItem.changed, 10)) {
        accumulator.notSynced.push(key);
      } else {
        accumulator.valid.push(key);
      }

      return accumulator;
    }, {
      valid: [],
      notSaved: [],
      notSynced: []
    });

    manifest.notSaved.forEach(function (uuid) {
      dispatch(a.setSaved(false, resource, uuid));
    });

    manifest.notSynced.forEach(function (uuid) {
      dispatch(a.markDirty(resource, uuid));
    });

    _logger2.default.log('validate', manifest);
    _logger2.default.groupEnd('validate', 'response');
  });
}

/**
 * Handles dispatching a failed API call's response.
 * @param  {Object}   resp     Response object instance.
 */
function handleValidateFailedResponse(resp) {
  return resp.json().then(function (json) {
    var err = json || resp.status + ': ' + (resp.statusText || 'No status message provided');
    _logger2.default.log('validate', 'Failed Validation json', err);
  });
}

/**
 * Handles dispatching a failed API call's response.
 * @param  {Object}   resp     Response object instance.
 * @param  {Function} dispatch Redux dispatch function.
 * @param  {String}   resource Resource type
 * @param  {Object}   model  EntityManager for this resource.
 * @param  {String}   [uuid]     UUID of the resource
 */
function handleValidateResponse(resp, items, dispatch, resource) {
  _logger2.default.log('validate', 'Response', resp, resource);

  if (resp.ok) {
    return handleValidateSuccessResponse(resp, items, dispatch, resource);
  }
  return handleValidateFailedResponse(resp, items, dispatch, resource);
}

/**
 * Handles dispatching a failed API call's response.
 * @param  {Object}   resp     Response object instance.
 * @param  {Function} dispatch Redux dispatch function.
 * @param  {String}   resource Resource type
 * @param  {String}   [uuid]     UUID of the resource
 */
function handleFailedResponse(resp, request, dispatch, resource, uuid) {
  return resp.json().then(function (json) {
    _logger2.default.log('network', 'Failed json response', json);

    var err = json || resp.status + ': ' + (resp.statusText || 'No status message provided');

    // Mark an non-existent entity as not saved.
    if (request.method === 'PATCH' && resp.status === 404) {
      dispatch(a.failure(err, resource, uuid));
      return dispatch(a.setSaved(false, resource, uuid));
    }

    // Mark an existing entity as saved.
    if (request.method === 'POST' && resp.status === 409) {
      dispatch(a.failure(err, resource, uuid));
      return dispatch(a.setSaved(true, resource, uuid));
    }

    return dispatch(a.failure(err, resource, uuid));
  }).catch(function (err) {
    return dispatch(a.failure(err, resource, uuid));
  });
}

/**
 * Processes included resources, adding them to the store.
 * @param {Function} dispatch
 *   Redux dispatch function
 * @returns {Function}
 *   Accepts an array of included resource objects, groups them by resource type and
 *   dispatches a receive action for each type.
 */
function processIncludes(dispatch) {
  return function (includes) {
    var resources = (0, _groupBy2.default)(includes, function (record) {
      return record.type;
    });
    (0, _forEach2.default)(resources, function (records, resource) {
      dispatch(a.receive({ data: records.map(_EntityModel.EntityModel.import) }, resource));
    });
  };
}

/**
 * Handles dispatching a successful API call's response.
 * @param  {Object}   resp     Response object instance.
 * @param  {Function} dispatch Redux dispatch function.
 * @param  {String}   resource Resource type
 * @param  {Object}   model  EntityManager for this resource.
 * @param  {String}   [uuid]     UUID of the resource
 */
function handleSuccessResponse(resp, dispatch, resource, model, uuid) {
  return resp.json().then(function (json) {
    _logger2.default.group('network', 'response');
    _logger2.default.log('network', 'Response: ' + resource, json);
    // Handle cases where the response doesn't have a nested data object,
    //  such as file uploads.
    var data = 'data' in json ? json.data : json;

    var output = {
      data: Array.isArray(data) ? data.map(_EntityModel.EntityModel.import) : _EntityModel.EntityModel.import(data)
    };

    _logger2.default.log('network', output.data);
    _logger2.default.groupEnd('network', 'response');

    if ('included' in json) {
      processIncludes(dispatch)(json.included);
    }

    return dispatch(a.receive(output, resource, uuid));
  });
}

/**
 * Handles dispatching a failed API call's response.
 * @param  {Object}   resp     Response object instance.
 * @param  {Function} dispatch Redux dispatch function.
 * @param  {String}   resource Resource type
 * @param  {Object}   model  EntityManager for this resource.
 * @param  {String}   [uuid]     UUID of the resource
 */
function handleResponse(resp, request, dispatch, resource, model, uuid) {
  _logger2.default.log('network', 'Response', resp, resource, uuid);

  if (resp.ok) {
    return handleSuccessResponse(resp, dispatch, resource, model, uuid);
  }
  return handleFailedResponse(resp, request, dispatch, resource, uuid);
}

/**
 * Handles a network error in a request.
 * @param  {Function} dispatch Redux dispatch function.
 * @param  {String}   resource [description]
 * @param  {[type]} id       [description]
 * @return {[type]}          [description]
 */
function handleNetworkError(dispatch, resource, id) {
  return function (error) {
    var message = 'There has been a problem with your connection: ' + error.message;
    dispatch(a.failure(message, resource, id));
    _logger2.default.log('network', message, error);
  };
}

var ApiManager = exports.ApiManager = function () {
  function ApiManager(options) {
    _classCallCheck(this, ApiManager);

    var model = options.model;

    this.model = model;
    this.type = model.type;
    this.bundle = model.bundle;
    this.resource = model.resource;
    this.fields = _defineProperty({}, model.resource, model.getFields(false));
    this.include = options.include || [];
    this.namespace = options.namespace || 'jsonapi';
    this.priority = options.priority || 9;
    this.latestFetch = null;

    // Bind methods.
    this.getLatestFetch = this.getLatestFetch.bind(this);
    this.setLatestFetch = this.setLatestFetch.bind(this);
    this.getEndpoint = this.getEndpoint.bind(this);
    this.getEndpointPath = this.getEndpointPath.bind(this);
    this.getRelationshipEndpoint = this.getRelationshipEndpoint.bind(this);
    this.getTimestampEndpoint = this.getTimestampEndpoint.bind(this);
    this.fetchAll = this.fetchAll.bind(this);
    this.fetchResource = this.fetchResource.bind(this);
    this.fetchTranslations = this.fetchTranslations.bind(this);
    this.sync = this.sync.bind(this);
    this.updateRelationshipsIfNeeded = this.updateRelationshipsIfNeeded.bind(this);
    this.backoffFetch = this.backoffFetch.bind(this);
    this.wrapFetch = this.wrapFetch.bind(this);

    // Register this instance.
    apiRegistrar.register(model.resource, this);
  }

  /**
   * Creates a url string for making JSON_API requests
   * @param  {object|string} options
   *  A url object as returned by url.parse() or a fully constructed url which will be passed through url.parse
   * @return {string} Fully formed url origin segment ex. https://www.example.com.
   */


  _createClass(ApiManager, [{
    key: 'getEndpointPath',


    /**
     * Creates a url string for making JSON_API requests
     * @param  {object|string} options
     *  A url object as returned by url.parse() or a fully constructed url which will be passed through url.parse
     * @return {string}
     *  Fully formed url origin segment ex. https://www.example.com.
     */
    value: function getEndpointPath() {
      return [this.namespace, this.type, this.bundle].join('/');
    }

    /**
     * Creates a query parameter object formatted for filters
     * See https://www.drupal.org/docs/8/modules/json-api/filtering
     * @param  {Object} filters
     *  @todo document
     * @return {Object}
     *  An object of query param key|value pairs
     */

  }, {
    key: 'getEndpointQueryParams',


    /**
     * Creates a query parameter object formatted for sparse fieldsets
     * See https://www.drupal.org/docs/8/modules/json-api/collections-filtering-and-sorting
     * See http://jsonapi.org/format/#fetching-sparse-fieldsets
     * @param  {Object} fields
     *  @todo document
     * @return {Object}
     *  An object of query param key|value pairs
     */
    value: function getEndpointQueryParams(options) {
      // Generate query params.
      var params = options.params || {};

      // Set filters if they exist.
      var filters = options.filters ? this.constructor.getEndpointFilters(options.filters) : {};

      // Set fields if they exist.
      var fields = this.constructor.getEndpointFields(options.fields || options.fields === null || this.fields || {});

      // Set include if they exist.
      var include = options.include ? this.constructor.getEndpointInclude(options.include) : {};

      // Set sorts if they exist.
      var sort = options.sort ? this.constructor.getEndpointSort(options.sort) : {};

      // Set limit if specified.
      var limit = options.limit ? this.constructor.getEndpointLimit(options.limit) : {};

      // Set offset if specified.
      var offset = options.offset ? this.constructor.getEndpointOffset(options.offset) : {};

      return (0, _assign5.default)(params, filters, fields, limit, include, offset, sort);
    }

    /**
     * Creates a url string for making JSON_API requests
     * @param  {string} resource        The machine name of the resource.
     * @param  {object} options         Additional request parameters.
     * @param  {string} [options.lang]
     *  Translation language code. _ex. 'en'
     * @param  {string} options.bundle  Entity bundle. ex. 'article', 'tags'
     * @param  {Object} [options.fields]  An object in which the properties are resource types and the value is an array of attribute name strings
     * @param  {Array}  [options.include] An array of resource type strings.
     *
     * @return {string}           Fully formed url.
     */

  }, {
    key: 'getEndpoint',
    value: function getEndpoint(options) {
      var origin = this.constructor.getEndpointOrigin();

      // Generate the path.
      var pathParts = [''];

      // Add translation if needed.
      if (options.lang) {
        pathParts.push(options.lang);
      }

      // Add the collection specific path parts.
      pathParts.push(this.getEndpointPath());

      // If this is resource specific, add the id.
      if (options.id) {
        pathParts.push(options.id);
      }

      var pathname = pathParts.join('/');

      // Generate query params.
      var query = this.getEndpointQueryParams({
        params: options.params,
        fields: options.fields,
        filters: options.filters,
        include: options.include,
        limit: options.limit,
        offset: options.offset,
        sort: options.sort
      });

      // Format the url string.
      return url.format({
        origin: origin,
        pathname: pathname,
        query: query
      });
    }

    /**
     * Creates a url string for making JSON_API relationship requests
     * @param  {object} options         Additional request parameters.
     * @param  {string} options.id      UUID o
     *
     * @return {string}           Fully formed url.
     */

  }, {
    key: 'getRelationshipEndpoint',
    value: function getRelationshipEndpoint(options) {
      var origin = this.constructor.getEndpointOrigin();

      // Generate the path.
      var pathParts = [''];
      // Add translation if needed.
      if (options.lang) {
        pathParts.push(options.lang);
      }
      // Add the collection specific path parts.
      pathParts.push(this.getEndpointPath());
      // If this is resource specific, add the id.
      pathParts.push(options.id);
      pathParts.push('relationships');
      pathParts.push(options.relationship);
      var pathname = pathParts.join('/');

      var query = this.getEndpointQueryParams({
        params: options.params,
        fields: options.fields,
        filters: options.filters,
        include: options.include
      });

      // Format the url string.
      return url.format({
        origin: origin,
        pathname: pathname,
        query: query
      });
    }
  }, {
    key: 'getTimestampEndpoint',
    value: function getTimestampEndpoint() {
      var origin = this.constructor.getEndpointOrigin();
      var pathname = 'intercept/time';

      // Format the url string.
      return url.format({
        origin: origin,
        pathname: pathname
      });
    }
  }, {
    key: 'getLatestFetch',
    value: function getLatestFetch() {
      return this.latestFetch;
    }
  }, {
    key: 'setLatestFetch',
    value: function setLatestFetch(id) {
      this.latestFetch = id;
      return id;
    }
  }, {
    key: 'fetcher',
    value: function fetcher() {
      var _this = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var nextLink = void 0;
      var totalFetched = 0;
      var done = false;
      var replace = options.replace || false;

      var getNextLink = function getNextLink() {
        return nextLink;
      };
      var getDone = function getDone() {
        return done;
      };

      return {
        next: function next() {
          return _this.fetchAll(_extends({}, options, {
            endpoint: getNextLink(),
            totalFetched: totalFetched,
            replace: replace,
            onNext: function onNext(endpoint, total) {
              nextLink = endpoint;
              totalFetched = total;
              replace = false;
            },
            onDone: function onDone() {
              if (options.onDone) {
                options.onDone();
              }
              done = true;
            }
          }));
        },
        isDone: function isDone() {
          return getDone();
        }
      };
    }

    /**
     * Fetches a resource collection.
     * @param {Object} options
     */

  }, {
    key: 'fetchAll',
    value: function fetchAll() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // on successful JSON response, map data to this.EntityModel.import
      // then dispatch success, type, data (transformed data)
      var backoffFetch = this.backoffFetch,
          resource = this.resource,
          getLatestFetch = this.getLatestFetch,
          setLatestFetch = this.setLatestFetch;
      var fetchTimestamp = this.constructor.fetchTimestamp;
      var _constructor = this.constructor,
          getRequest = _constructor.getRequest,
          getTimestamp = _constructor.getTimestamp;

      var currentFetch = setLatestFetch((0, _v2.default)());

      var filters = options.filters || [];
      var include = options.include || [];
      var sort = options.sort || [];
      var count = options.count || 0;
      var totalFetched = options.totalFetched || 0;
      var fields = options.fields,
          limit = options.limit,
          offset = options.offset,
          onNext = options.onNext,
          onDone = options.onDone;

      var _fetchAll = this.fetchAll.bind(this);
      var replace = options.replace || false;

      return function (dispatch, getState) {
        var state = getState();

        //
        // Handle request for recent content.
        //
        if (options.recent && state[resource].updated) {
          filters.push({
            path: 'changed',
            value: state[resource].updated,
            operator: '>'
          });
        }

        //
        // Construct and endpoint if one was not supplied
        //
        var endpoint = options.endpoint || _this2.getEndpoint({
          filters: filters,
          include: include,
          fields: fields,
          sort: sort,
          limit: limit,
          offset: offset
        });

        //
        // Generate the request object
        //
        var request = getRequest(endpoint, options);

        //
        // Dispatch API collection request action.
        //
        dispatch(a.request(resource));
        _logger2.default.log('network', 'Request', request);

        //
        // Make the actual API call
        //
        function makeApiCall() {
          //
          // Get the current timestamp
          // This is referenced later when fetching fresh data, or data changed after this timestamp.
          //
          var fetchTime = fetchTimestamp(getState).then(function (time) {
            return time;
          }).catch(function (err) {
            _logger2.default.log(err);
          });

          //
          // Fetch the data.
          //
          var fetchData = backoffFetch(request, responseHandler, errorHandler).then(function (resp) {
            //
            // Handle an OK response
            //
            if (resp.ok) {
              resp.json().then(function (json) {
                //
                // Abort if there's a new request in route.
                //
                if (replace && currentFetch !== getLatestFetch()) {
                  return;
                }

                //
                // Ensure the response data is an Array
                //
                var output = {
                  data: [].concat(json.data)
                };

                totalFetched += output.data.length;

                //
                // Log network response
                //
                _logger2.default.group('network', 'response');
                _logger2.default.log('network', 'Response: ' + getTimestamp() + ' ' + resource, json);
                _logger2.default.log('network', output.data);
                _logger2.default.groupEnd('network', 'response');

                //
                // Process included resources.
                //
                if ('included' in json) {
                  processIncludes(dispatch)(json.included);
                }

                //
                // Purge store if replacing.
                //
                if (replace) {
                  dispatch(a.purge(resource));
                  // Ensure it only purges once.
                  replace = false;
                }

                //
                // Dispatch Receive action
                //
                dispatch(a.receive(output, resource));

                var hasMore = json.links && json.links.next;

                if (!hasMore) {
                  // Call onDone() then exit.
                  if (onDone) {
                    onDone();
                  }
                  return;
                }

                //
                // Recursively fetch paginated items.
                //
                if (count === 0 || count > totalFetched) {
                  dispatch(_fetchAll(_extends({}, options, {
                    endpoint: json.links.next,
                    totalFetched: totalFetched,
                    replace: replace
                  })));
                } else if (onNext) {
                  // Call onNext()
                  onNext(json.links.next, totalFetched);
                }
              });
            }
            //
            // Handle a NOT OK response
            //
            else {
                dispatch(a.failure(resp.status + ': ' + (resp.statusText || 'No status message provided'), resource));
              }

            return resp;
          })
          //
          // Catch network error
          //
          .catch(handleNetworkError(dispatch, resource));

          return Promise.all([fetchTime, fetchData]).then(function (values) {
            //
            // Set the collection updated timestamp.
            //
            dispatch(a.setTimestamp(resource, values[0]));
            //
            // Return the fetched data.
            //
            return values[1];
          }).catch(function (err) {
            _logger2.default.log(err);
          });
        }

        //
        // Make the API call
        //
        return makeApiCall();
      };
    }

    /**
     * Fetches a resource collection.
     * @param {Object} options
     */

  }, {
    key: 'fetchResource',
    value: function fetchResource(uuid) {
      var _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // on successful JSON response, map data to this.EntityModel.import
      // then dispatch success, type, data (transformed data)
      var backoffFetch = this.backoffFetch,
          resource = this.resource;
      var _constructor2 = this.constructor,
          getRequest = _constructor2.getRequest,
          getTimestamp = _constructor2.getTimestamp;


      var include = options.include || [];
      var fields = options.fields;


      return function (dispatch) {
        //
        // Construct and endpoint if one was not supplied
        //
        var endpoint = options.endpoint || _this3.getEndpoint({
          include: include,
          fields: fields,
          id: uuid
        });

        //
        // Generate the request object
        //
        var request = getRequest(endpoint, options);

        //
        // Dispatch API collection request action.
        //
        dispatch(a.request(resource, uuid));
        _logger2.default.log('network', 'Request', request);

        //
        // Make the actual API call
        //
        function makeApiCall() {
          //
          // Fetch the data.
          //
          var fetchData = backoffFetch(request, responseHandler, errorHandler).then(function (resp) {
            //
            // Handle an OK response
            //
            if (resp.ok) {
              resp.json().then(function (json) {
                //
                // Ensure the response data is an Array
                //
                var output = {
                  data: json.data
                };

                //
                // Log network response
                //
                _logger2.default.group('network', 'response');
                _logger2.default.log('network', 'Response: ' + getTimestamp() + ' ' + resource, json);
                _logger2.default.log('network', output.data);
                _logger2.default.groupEnd('network', 'response');

                //
                // Process included resources.
                //
                if ('included' in json) {
                  processIncludes(dispatch)(json.included);
                }

                //
                // Dispatch Receive action
                //
                dispatch(a.receive(output, resource, uuid));
              });
            }
            //
            // Handle a NOT OK response
            //
            else {
                dispatch(a.failure(resp.status + ': ' + (resp.statusText || 'No status message provided'), resource, uuid));
              }

            return resp;
          })
          //
          // Catch network error
          //
          .catch(handleNetworkError(dispatch, resource, uuid));

          return Promise.all([fetchData])
          //
          // Return the fetched data.
          //
          .then(function (values) {
            return values[1];
          }).catch(function (err) {
            _logger2.default.log(err);
          });
        }

        //
        // Make the API call
        //
        return makeApiCall();
      };
    }

    // Fetch related translations.

  }, {
    key: 'fetchTranslations',
    value: function fetchTranslations() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // on successful JSON response, map data to this.EntityModel.import
      // then dispatch success, type, data (transformed data)
      var backoffFetch = this.backoffFetch,
          fields = this.fields,
          include = this.include,
          resource = this.resource,
          priority = this.priority;
      var _constructor3 = this.constructor,
          getRequest = _constructor3.getRequest,
          getTimestamp = _constructor3.getTimestamp;


      var _fetchTranslations = this.fetchTranslations.bind(this);

      return function (dispatch, getState) {
        var state = getState();

        // Exit if we're not logged in.
        if (!state.userData.auth.loggedIn) {
          _logger2.default.log('network', 'User is logged out: Aborting request.');
          return Promise.resolve('Aborted');
        }

        var limit = options.limit,
            offset = options.offset;


        var endpoint = options.endpoint || _this4.getEndpoint({
          fields: fields,
          include: include,
          langcode: options.langcode,
          filters: [].concat(options.filters, {
            path: 'langcode',
            value: options.langcode,
            operator: '='
          }),
          limit: limit,
          offset: offset
        });

        var request = getRequest(endpoint, options);

        // Dispatch generic api request action.
        dispatch(a.request(resource));

        _logger2.default.log('network', 'Request', request);

        function makeApiCall() {
          return backoffFetch(request, responseHandler, errorHandler).then(function (resp) {
            if (resp.ok) {
              resp.json().then(function (json) {
                var output = {
                  data: [].concat(json.data).map(_EntityModel.EntityModel.import)
                };

                // @todo Handle transforming included resources.
                _logger2.default.group('network', 'response');
                _logger2.default.log('network', 'Priority: ' + priority);
                _logger2.default.log('network', 'Translation Response: ' + getTimestamp() + ' ' + options.langcode + ' ' + resource, json);
                _logger2.default.log('network', output.data);
                _logger2.default.groupEnd('network', 'response');

                dispatch(a.receiveTranslation(output, resource, options.langcode));

                // Recursively fetch paginated items.
                if (json.links && json.links.next) {
                  dispatch(_fetchTranslations({
                    endpoint: json.links.next,
                    langcode: options.langcode
                  }));
                }
              });
            } else {
              dispatch(a.failure(resp.status + ': ' + (resp.statusText || 'No status message provided'), resource));
            }

            return resp;
          })
          // Catch network error.
          .catch(handleNetworkError(dispatch, resource));
        }

        return makeApiCall();
      };
    }

    // Clear API Errors

  }, {
    key: 'clearErrors',
    value: function clearErrors() {
      var resource = this.resource;


      _logger2.default.log('network', 'Running Clear errors on ' + resource + '.');

      return function (dispatch) {
        dispatch(a.clearErrors(resource));
      };
    }

    // Clear API Errors

  }, {
    key: 'markDirty',
    value: function markDirty() {
      var resource = this.resource;


      _logger2.default.log('network', 'Marking all ' + resource + ' items as dirty.');

      return function (dispatch) {
        dispatch(a.markDirty(resource));
      };
    }

    // Purge local store

  }, {
    key: 'purge',
    value: function purge() {
      var resource = this.resource;


      return function (dispatch) {
        dispatch(a.purge(resource));
      };
    }

    // Reset API store

  }, {
    key: 'reset',
    value: function reset() {
      var resource = this.resource;


      return function (dispatch) {
        dispatch(a.reset(resource));
      };
    }

    /**
     * Syncs data using either POST or PATCH based on the saved status of the entity.
     * @param  {String} uuid   UUID of the entity to create remotely.
     * @return {Function}      Redux thunk.
     */

  }, {
    key: 'removeRelationship',
    value: function removeRelationship(relationship, uuid) {
      var backoffFetch = this.backoffFetch,
          bundle = this.bundle,
          model = this.model,
          resource = this.resource,
          type = this.type;
      var _constructor4 = this.constructor,
          getRequest = _constructor4.getRequest,
          getRelationshipEndpoint = _constructor4.getRelationshipEndpoint;


      return function (dispatch, getState) {
        var state = getState();
        var entity = state[resource].items[uuid];

        // Abort if a request is already in progress.
        // or if this request previously errored.
        // @todo Determine a better way to handle errors. The current implementation
        // will prevent an infinite loop of error requests but will also prevent
        // reattempts in case of network errors.
        // if (entity.state.syncing) {
        if (entity.state.syncing || entity.state.error) {
          return Promise.resolve('Aborted');
        }

        var method = 'PATCH';

        var data = {
          data: null
        };

        var endpointParts = {
          type: type,
          bundle: bundle,
          relationship: relationship,
          uuid: uuid
        };

        var endpoint = getRelationshipEndpoint(endpointParts);

        var request = getRequest(endpoint, {
          method: method,
          body: JSON.stringify(data)
        });

        _logger2.default.log('network', method, request);

        // Dispatch generic api request action.
        dispatch(a.request(resource, uuid));

        function makeApiCall() {
          return backoffFetch(request, responseHandler, errorHandler).then(function (resp) {
            return handleResponse(resp, request, dispatch, resource, model, uuid);
          })
          // Catch network error.
          .catch(handleNetworkError(dispatch, resource, uuid));
        }

        return makeApiCall();
      };
    }

    /**
     * Syncs data using either POST or PATCH based on the saved status of the entity.
     * @param  {String} uuid   UUID of the entity to create or update remotely.
     * @return {Function}      Redux thunk.
     */

  }, {
    key: 'sync',
    value: function sync(uuid, options) {
      var _this5 = this;

      var backoffFetch = this.backoffFetch,
          model = this.model,
          include = this.include,
          resource = this.resource;
      var getRequest = this.constructor.getRequest;


      var updateRelationshipsIfNeeded = this.updateRelationshipsIfNeeded.bind(this);

      return function (dispatch, getState) {
        var state = getState();
        var entity = state[resource].items[uuid];

        // Abort if a request is already in progress.
        // or if this request previously errored.
        // @todo Determine a better way to handle errors. The current implementation
        // will prevent an infinite loop of error requests but will also prevent
        // reattempts in case of network errors.
        if (entity.state.syncing) {
          return Promise.reject(new Error('Entity already syncing.'));
        }

        if (entity.state.error) {
          return Promise.reject(new Error('Will not retry a request with an error state.'));
        }

        // Has this entity successfully saved to remotely?
        var saved = entity.state.saved;
        // Determine the HTTP method based on saved status.

        var method = saved ? 'PATCH' : 'POST';
        // Format for local entity data for jsonapi
        var data = _EntityModel.EntityModel.export(entity, state);

        //
        // Create API endpoint string
        //
        var endpointParts = {
          include: include
        };
        // Add the uuid to the endpoint if this entity exists remotely.
        if (saved) {
          (0, _assign5.default)(endpointParts, { id: uuid });
        }
        var endpoint = options.endpoint || _this5.getEndpoint(endpointParts);

        var request = getRequest(endpoint, _extends({}, options, {
          method: method,
          body: JSON.stringify(data)
        }));

        function makeApiCall() {
          return backoffFetch(request, responseHandler, errorHandler).then(function (resp) {
            return handleResponse(resp, request, dispatch, resource, model, uuid);
          }).then(function (action) {
            // If this is an update operation, we need to update relationships as well.
            if (saved) {
              return updateRelationshipsIfNeeded(dispatch, entity.data, action.resp.data);
            }
          }).catch(function (err) {
            _logger2.default.log('network', 'we give up', err);
            handleNetworkError(dispatch, resource, uuid)(err);
            return Promise.reject(err);
          });
        }

        _logger2.default.log('network', method, request);

        // Dispatch generic api request action.
        dispatch(a.request(resource, uuid));

        return makeApiCall();
      };
    }

    /**
     * Compares local data with remote data to determine if we need to remove any entity references.
     * @param  {Function} dispatch Redux dispatch function.
     * @param  {Object}   localData   Entity data from the local redux store.
     * @param  {Object}   remoteData  Entity data from the remote server.
     */

  }, {
    key: 'updateRelationshipsIfNeeded',
    value: function updateRelationshipsIfNeeded(dispatch, localData, remoteData) {
      var _this6 = this;

      var relationships = this.model.getRelationshipAliases();
      var dirtyRelationships = (0, _filter2.default)(relationships, function (r) {
        return (
          // If a relationship exists remotely but not locally, it's dirty.
          !localData[r] && localData[r] !== remoteData[r]
        );
      });
      var removeRelationship = this.removeRelationship.bind(this);

      return Promise.all(dirtyRelationships.map(function (r) {
        return dispatch(removeRelationship(_this6.model.getPropertyFromAlias(r), localData.uuid));
      }));
    }

    /**
     * Normalizes the resolution and rejection of a fetch request.
     * @param  {Request} request The request object. https://developer.mozilla.org/en-US/docs/Web/API/Request
     * @param  {responseHandlerCallback} responseHandler - The callback that handles the response.
     * @param  {errorHandlerCallback} errorHandler - The callback that handles the error from a failed request.
     * @return {Promise}         A promise that will resolve if the fetch response is OK. It will reject otherwise.
     */

  }, {
    key: 'wrapFetch',
    value: function wrapFetch(request) {
      var priority = this.priority;


      return function () {
        var limiter = request.method === 'GET' ? readLimiter : writeLimiter;
        function makeApiCall() {
          return new Promise(function (resolve, reject) {
            // Fetch the request.
            fetch(request.clone())
            // Handle a successful request.
            .then(responseHandler(request, resolve, reject)).catch(errorHandler(request, resolve, reject));
          });
        }

        return limiter.schedule({ priority: priority }, makeApiCall, request);
      };
    }

    /**
     * Retries a failed request using Exponential Backoff.
     * @param  {Request} request The request object. https://developer.mozilla.org/en-US/docs/Web/API/Request
     * @param  {responseHandlerCallback} responseHandler - The callback that handles the response.
     * @param  {errorHandlerCallback} errorHandler - The callback that handles the error from a failed request.
     * @return {Promise}  A wrapped fetch request that will retry if it encounters a failure.
     */

  }, {
    key: 'backoffFetch',
    value: function backoffFetch(request) {
      return (0, _exponentialBackoff2.default)(this.wrapFetch(request));
    }
  }], [{
    key: 'getEndpointOrigin',
    value: function getEndpointOrigin(options) {
      // Format the url string.
      return options ? new URL(url.format(options)).origin : '/';
    }
  }, {
    key: 'getEndpointFilters',
    value: function getEndpointFilters(filters) {
      return (0, _reduce2.default)(filters, function (query, value, key) {
        var output = (0, _assign5.default)({}, query);
        var type = value.type || 'condition';
        var multiOperators = ['IN', 'NOT IN', 'BETWEEN'];
        var useShorthand = 'operator' in value === false && 'condition' in value === false && 'memberOf' in value === false && 'type' in value === false;

        // Handle shorthand filters.
        if (useShorthand) {
          output['filter[' + value.path + '][value]'] = value.value;
          return output;
        }

        // Handle groups
        if (type === 'group') {
          // Default to AND if conjuction is not specified.
          output['filter[' + key + '][group][conjunction]'] = value.conjunction || 'AND';

          if ('memberOf' in value) {
            output['filter[' + key + '][group][memberOf]'] = value.memberOf;
          }

          return output;
        }

        // Handle default
        output['filter[' + key + '][condition][path]'] = value.path;

        // Handle multi-value operators.
        if (multiOperators.indexOf(value.operator) > -1) {
          output['filter[' + key + '][condition][value][]'] = value.value;
        } else {
          output['filter[' + key + '][condition][value]'] = value.value;
        }

        if ('operator' in value) {
          output['filter[' + key + '][condition][operator]'] = value.operator;
        }

        if ('memberOf' in value) {
          output['filter[' + key + '][condition][memberOf]'] = value.memberOf;
        }

        return output;
      }, {});
    }

    /**
     * Creates a query parameter object formatted for sorts
     * See https://www.drupal.org/docs/8/modules/json-api/collections-and-sorting
     * @param  {Object} sort
     *  @todo document
     * @return {Object}
     *  An object of query param key|value pairs
     */

  }, {
    key: 'getEndpointSort',
    value: function getEndpointSort(sort) {
      var output = (0, _reduce2.default)(sort, function (query, value) {
        var direction = value.direction === 'DESC' ? '-' : '';
        var sortParam = '' + direction + value.path;
        return query ? [].concat(query, sortParam).join(',') : sortParam;
      }, null);

      return output === null ? {} : { sort: output };
    }

    /**
     * Creates a query parameter object formatted for sparse fieldsets
     * See https://www.drupal.org/docs/8/modules/json-api/collections-filtering-and-sorting
     * See http://jsonapi.org/format/#fetching-sparse-fieldsets
     * @param  {Object} fields
     *  @todo document
     * @return {Object}
     *  An object of query param key|value pairs
     */

  }, {
    key: 'getEndpointFields',
    value: function getEndpointFields(fields) {
      if (fields === null) {
        return {};
      }

      return (0, _reduce2.default)(fields, function (query, value, key) {
        return (0, _assign5.default)(query, _defineProperty({}, 'fields[' + key + ']', value.join(',')));
      }, {});
    }

    /**
     * Creates a query parameter object formatted for including related resources
     * See https://www.drupal.org/docs/8/modules/json-api/fetching-resources-get
     * See http://jsonapi.org/format/#fetching-includes
     * @param  {Object} include
     *  @todo document
     * @return {Object}
     *  An object of query param key|value pairs
     */

  }, {
    key: 'getEndpointInclude',
    value: function getEndpointInclude(include) {
      // Set includes if they exist.
      return Array.isArray(include) && include.length > 0 ? { include: include.join(',') } : {};
    }

    /**
     * Creates a query parameter object formatted for pagination limit
     * See https://www.drupal.org/docs/8/modules/json-api/pagination
     * See http://jsonapi.org/format/#fetching-pagination
     * @param  {number} limit
     *  @todo document
     * @return {Object}
     *  An object of query param key|value pairs
     */

  }, {
    key: 'getEndpointLimit',
    value: function getEndpointLimit(limit) {
      return limit ? { 'page[limit]': limit } : {};
    }

    /**
     * Creates a query parameter object formatted for pagination offset
     * See https://www.drupal.org/docs/8/modules/json-api/pagination
     * See http://jsonapi.org/format/#fetching-pagination
     * @param  {number} offset
     *  @todo document
     * @return {Object}
     *  An object of query param key|value pairs
     */

  }, {
    key: 'getEndpointOffset',
    value: function getEndpointOffset(offset) {
      return offset ? { 'page[offset]': offset } : {};
    }
  }, {
    key: 'getTimestamp',
    value: function getTimestamp() {
      var now = new Date();
      return Math.floor(now / 1000);
    }

    /**
     * Creates a resource object to make a JSON_API fetch request
     * @param  {string} endpoint    A fully formed url.
     * @param  {object} [options]   Additional request options.
     * @param  {string} [options.method = 'GET'] GET|POST|PATCH|DELETE
     * @param  {string} [options.token]   JWT token. If omited, the request will be unathenticated and will most likely fail.
     * @param  {string} [options.headers] Additional headers
     * @return {object}          A Request object https://developer.mozilla.org/en-US/docs/Web/API/Request
     */

  }, {
    key: 'getRequest',
    value: function getRequest(endpoint) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // Assume we're talking JSON_API.
      var defaultHeaders = {
        Accept: 'application/vnd.api+json',
        'Content-Type': 'application/vnd.api+json'
      };

      var requestOptions = {
        method: options.method || 'GET',
        headers: (0, _assign5.default)({}, defaultHeaders, options.headers || {}),
        credentials: 'same-origin'
      };

      // Add the body field if we have one.
      if (options.body) {
        (0, _assign5.default)(requestOptions, { body: options.body });
      }

      // Return the Request object.
      return new Request(endpoint, requestOptions);
    }
  }, {
    key: 'fetchTimestamp',
    value: function fetchTimestamp() {
      return Promise.resolve(Math.floor(new Date().getTime() / 1000));
    }
  }]);

  return ApiManager;
}();

/**
 * Initial state of an api data store.
 * @type {Object}
 */
var initialDataState = {
  items: {},
  validating: false,
  syncing: false,
  error: null,
  updated: null
};

/**
 * Creates a new data item from an api call.
 * @param  {Object} data Data used to populate item.data.
 * @return {Object}      A new item with data and state properties populated.
 */
function itemImport(data) {
  var output = {
    data: data,
    state: {
      syncing: false,
      saved: true,
      error: null,
      dirty: false
    }
  };

  return output;
}

/**
 * Creates a new data item from an existing item, overriding any specified data properties.
 * @param  {Object} item Existing item from the store
 * @param  {Object} data Data used to populate item.data.
 * @return {Object}      A new item with data and state properties populated.
 */
function itemEdit(item, data) {
  var output = (0, _assign5.default)({}, item);
  output.data = _extends({}, item.data, data);
  output.state = _extends({}, item.state, {
    error: null,
    dirty: true
  });
  return output;
}

function editItems(items, data) {
  var output = (0, _assign5.default)({}, items);

  // Loop through each new data point.
  (0, _forEach2.default)(data, function (d) {
    output[d.uuid] = itemEdit(items[d.uuid], d);
  });

  return output;
}

function mergeProp(prop, x, y) {
  if (x[prop] || y[prop]) {
    return _extends({}, x[prop], y[prop]);
  }
}

/**
 * Creates a new data item from an existing item, overriding data properties from an api response.
 * @param  {Object} item Existing item from the store
 * @param  {Object} data Data used to populate item.data.
 * @return {Object}      A new item with data and state properties populated.
 */
function itemUpdate(item, input) {
  var output = Object.assign({}, item);

  output.data = item.data || {};

  output.data.attributes = mergeProp('attributes', item.data, input);
  output.data.relationships = mergeProp('relationships', item.data, input);
  output.data.meta = mergeProp('meta', item.data, input);
  output.data.links = mergeProp('links', item.data, input);

  output.state = _extends({}, item.state, {
    saved: true
  });

  return output;
}

/**
 * Creates a new data item from an existing item, overriding data properties from an api response.
 * @param  {Object} item Existing item from the store
 * @param  {Object} data Data used to populate item.data.
 * @return {Object}      A new item with data and state properties populated.
 */
function itemUpdateTimestamps(item, data) {
  var output = (0, _assign5.default)({}, item);
  output.data = item.data;

  var limitFieldsTo = ['created', 'changed', 'id'];

  limitFieldsTo.forEach(function (field) {
    if (data[field]) {
      output.data[field] = data[field];
    }
  });

  output.state = _extends({}, item.state, {
    saved: true
  });
  return output;
}

/**
 * Prepares an item from an api call to be merged into the items collection.
 * @param  {Object} items Collection of data items.
 * @param  {Object} data    The new data to be merged from an api response.
 * @param  {String} mergeStrategy  The merge strategy for handling incoming data
 * @return {Object}         A new item with data and state properties populated.
 */
function mergeItem(items, data, mergeStrategy) {
  switch (mergeStrategy) {
    case 'mergeNew':
      // Only add new items.
      return data.id in items ? items[data.id] : itemImport(data);
    default:
      // Update existing items.
      return data.id in items ? itemUpdate(items[data.id], data) : itemImport(data);
  }
}

/**
 * Merges items from an api response into an existing collection.
 * @param  {Object} items Collection of existing items.
 * @param  {Array}  data  An array of items from an api response.
 * @param  {String} mergeStrategy  The merge strategy for handling incoming data
 * @return {Object}       A new collection with items from the api response merged into the existing collection.
 */
function mergeItems(items, data, mergeStrategy) {
  var output = (0, _assign5.default)({}, items);

  // Loop through each new data point.
  (0, _forEach2.default)(data, function (d) {
    output[d.id] = mergeItem(items, d, mergeStrategy);
  });

  return output;
}

/**
 * Resets the error state of all items to null.
 *   When setting the dirty state we check for an error status as early < 1.1.4.1 versions
 *    of the app would not reset the dirty value to true after a failed response.
 * @param  {Object} items Collection of existing items.
 * @return {Object}       A new collection with items with errors set to null.
 */
function clearItemsErrors(items) {
  return (0, _mapValues2.default)(items, function (item) {
    return _extends({}, item, {
      state: _extends({}, item.state, {
        dirty: item.state.dirty || item.state.error !== null || item.state.syncing || false,
        syncing: false,
        error: null
      })
    });
  });
}

/**
 * Sets the state of all items to dirty.
 * @param  {Object} items Collection of existing items.
 * @return {Object}       A new collection with items with errors set to null.
 */
function markItemsDirty(items) {
  return (0, _mapValues2.default)(items, function (item) {
    return _extends({}, item, {
      state: _extends({}, item.state, {
        dirty: true
      })
    });
  });
}

/**
 * Prepares an item from an api call to be merged into the items collection.
 * @param  {Object} items Collection of data items.
 * @param  {Object} data    The new data to be merged from an api response.
 * @param  {String} mergeStrategy  The merge strategy for handling incoming data
 * @param  {String} lancode  The 2 letter ISO_639-1 language code.
 * @return {Object}         A new item with data and state properties populated.
 */
function mergeTranslation(items, data, mergeStrategy, langcode) {
  var output = (0, _assign5.default)({}, items[data.uuid]);
  var translations = 'translations' in output.data ? output.data.translations : {};
  output.data.translations = (0, _assign5.default)(translations, _defineProperty({}, langcode, data));

  return output;
}

/**
 * Merges items from an api response into an existing collection.
 * @param  {Object} items Collection of existing items.
 * @param  {Array}  data  An array of items from an api response.
 * @param  {String} mergeStrategy  The merge strategy for handling incoming data
 * @param  {String} lancode  The 2 letter ISO_639-1 language code.
 * @return {Object}       A new collection with items from the api response merged into the existing collection.
 */
function mergeTranslations(items, data, mergeStrategy, langcode) {
  var output = (0, _assign5.default)({}, items);

  // Loop through each new data point.
  (0, _forEach2.default)(data, function (d) {
    if (output[d.uuid]) {
      output[d.uuid] = mergeTranslation(items, d, mergeStrategy, langcode);
    }
  });

  return output;
}

/**
 * Generic API reducer for dealing with single items.
 * @param  {Object} state  Current state of the Redux store
 * @param  {Object} action Flux standard action
 * @return {Object}        The altered state of the store
 */
function dataReducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialDataState;
  var action = arguments[1];
  var mergeStrategy = arguments[2];

  // Grab common variables from the action payload.
  var id = action.id,
      data = action.data;


  var item = {};

  // Exit if we the item doesn't already exist and we're trying to do something other than updating.
  if (id in state === false && [t.ADD, t.RECEIVE].indexOf(action.type) < 0) {
    return state;
  }

  // Create a copy of the item.
  item = (0, _assign5.default)({}, state[id]);

  switch (action.type) {
    case t.CLEAR_ERRORS:
      item.state = _extends({}, item.state, {
        dirty: item.state.dirty || item.state.error !== null || item.state.syncing || false,
        syncing: false,
        error: null
      });
      break;
    case t.SET_SAVED:
      item.state = _extends({}, item.state, {
        dirty: true,
        error: null,
        saved: action.value
      });
      break;
    case t.MARK_DIRTY:
      item.state = _extends({}, item.state, {
        dirty: true
      });
      break;
    case t.REQUEST:
      item.state = _extends({}, item.state, {
        syncing: true,
        dirty: false
      });
      break;
    case t.RECEIVE:
      if (id in state === false) {
        item.data = action.resp.data;
        item.state = {
          dirty: false,
          saved: true,
          syncing: false,
          error: null
        };
      } else {
        // If the item is now dirty, let's not update it again as we will
        //   lose changes and need to sync again anyway.
        if (action.resp.data && !item.state.dirty) {
          // item.data = action.resp.data;
          item = mergeStrategy === 'mergeNew' ? itemUpdateTimestamps(item, action.resp.data) : itemUpdate(item, action.resp.data);
        }
        item.state = _extends({}, item.state, {
          saved: true,
          syncing: false,
          error: null
        });
      }
      break;
    case t.FAILURE:
      item.state = _extends({}, item.state, {
        syncing: false,
        error: action.error,
        dirty: true
      });
      break;
    case t.ADD:
      item.data = data;
      item.state = {
        saved: false,
        syncing: false,
        error: null,
        dirty: true
      };
      break;
    case t.EDIT:
      item = itemEdit(item, data);
      break;
    default:
      break;
  }

  return (0, _assign5.default)({}, state, _defineProperty({}, id, item));
}

/**
 * Creates an api Redux reducer for a specific resource type
 * @param  {String} resource JSON_API resource type.
 * @param  {String} mergeStrategy  The merge strategy for handling incoming data
 * @return {Function}        Reducer function for handling API data
 */
function apiReducer(resource, mergeStrategy) {
  return function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialDataState;
    var action = arguments[1];

    // Only respond to the actions we care about.
    if ([t.CLEAR_ERRORS, t.SET_SAVED, t.SET_VALIDATING, t.REQUEST, t.RECEIVE, t.RECEIVE_TRANSLATION, t.FAILURE, t.MARK_DIRTY, t.PURGE, t.RESET, t.SET_TIMESTAMP, t.ADD, t.EDIT].indexOf(action.type) === -1) {
      return state;
    }

    // Return State if this is not the resource we care about.
    if (action.resource !== resource) {
      return state;
    }

    //
    // Handle full collection actions.
    //
    if (!action.id) {
      switch (action.type) {
        case t.CLEAR_ERRORS:
          return _extends({}, state, {
            items: clearItemsErrors(state.items),
            syncing: false,
            error: null
          });
        case t.MARK_DIRTY:
          return _extends({}, state, {
            items: markItemsDirty(state.items)
          });
        case t.REQUEST:
          return _extends({}, state, {
            syncing: true
          });
        case t.SET_TIMESTAMP:
          return _extends({}, state, {
            updated: action.timestamp
          });
        case t.RECEIVE:
          return _extends({}, state, {
            items: mergeItems(state.items, action.resp.data, mergeStrategy),
            syncing: false,
            error: null
          });
        case t.RECEIVE_TRANSLATION:
          return _extends({}, state, {
            // @todo this will override all local data with the response.
            // Fine for read-only resources ie. Testlet, Testlet Items
            // Need a merge strategy for other Students, Classes, Assessments etc.
            items: mergeTranslations(state.items, action.resp.data, mergeStrategy, action.langcode),
            syncing: false,
            error: null
          });
        case t.PURGE:
          // Removes all locally stored items!
          return _extends({}, state, {
            items: {},
            syncing: false,
            error: null,
            updated: null
          });
        case t.FAILURE:
          // Log failure remotely.
          return _extends({}, state, {
            isFetching: false,
            error: action.error
          });
        case t.RESET:
          return _extends({}, state, {
            syncing: false,
            error: null,
            updated: null
          });
        case t.SET_VALIDATING:
          return _extends({}, state, {
            validating: action.value
          });
        case t.EDIT:
          return _extends({}, state, {
            items: editItems(state.items, action.data)
          });
        default:
          return state;
      }
    }

    //
    // Handle single entity requests
    //
    return _extends({}, state, {
      items: dataReducer(state.items, action, mergeStrategy)
    });
  };
}