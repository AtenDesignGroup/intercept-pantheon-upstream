'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _arguments = arguments;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* eslint prefer-destructuring: "off" */
var logger = {};
exports.default = logger;


logger.canLog = null;
logger.canApply = null;
logger.canGroup = null;
logger.canError = null;

// define contexts and whether they can console.log or not
// import {LOG} from './../config';
var LOG = false;
logger.debugSettings = LOG;

/**
 * Check if we are in a console capable system
 */
logger.init = function () {
  logger.canLog = typeof console !== 'undefined' && typeof console.log !== 'undefined';
  logger.canApply = typeof console.log.apply !== 'undefined';
  logger.canGroup = typeof console.group !== 'undefined';
  logger.canError = typeof console.error !== 'undefined';
};

/**
 * Log a message, taking context and loggability into account.
 */
logger.log = function () {
  var context = 'master';
  var thisArguments = Array.prototype.slice.call(_arguments);

  if (logger.canLog === null) {
    logger.init();
  }

  if (_arguments.length > 1) {
    if (typeof _arguments[0] === 'string' && typeof logger.debugSettings[_arguments[0]] !== 'undefined') {
      context = _arguments[0];
      thisArguments.shift();
    }
  }

  if (typeof logger.debugSettings[context] !== 'undefined' && logger.debugSettings[context]) {
    if (logger.canLog) {
      if (logger.canApply) {
        var _console;

        return (_console = console).log.apply(_console, _toConsumableArray(thisArguments));
      }

      // non-apply version for some browsers (*cough* ie)
      console.log(thisArguments);
    }
  }
};

/**
 * Log a message, taking context and loggability into account.
 */
logger.group = function () {
  var context = 'master';
  var thisArguments = Array.prototype.slice.call(_arguments);

  if (logger.canLog === null) {
    logger.init();
  }

  if (_arguments.length > 1) {
    if (typeof _arguments[0] === 'string' && typeof logger.debugSettings[_arguments[0]] !== 'undefined') {
      context = _arguments[0];
      thisArguments.shift();
    }
  }

  if (typeof logger.debugSettings[context] !== 'undefined' && logger.debugSettings[context]) {
    if (logger.canGroup) {
      // non-apply version for some browsers (*cough* ie)
      console.group(thisArguments);
    }
  }
};

/**
 * Log a message, taking context and loggability into account.
 */
logger.groupEnd = function () {
  var context = 'master';
  var thisArguments = Array.prototype.slice.call(_arguments);

  if (logger.canLog === null) {
    logger.init();
  }

  if (_arguments.length > 1) {
    if (typeof _arguments[0] === 'string' && typeof logger.debugSettings[_arguments[0]] !== 'undefined') {
      context = _arguments[0];
      thisArguments.shift();
    }
  }

  if (typeof logger.debugSettings[context] !== 'undefined' && logger.debugSettings[context]) {
    if (logger.canGroup) {
      // non-apply version for some browsers (*cough* ie)
      console.groupEnd(thisArguments);
    }
  }
};

/**
 * Log a message, taking context and loggability into account.
 */
logger.error = function () {
  var context = 'master';
  var thisArguments = Array.prototype.slice.call(_arguments);

  if (logger.canError === null) {
    logger.init();
  }

  if (_arguments.length > 1) {
    if (typeof _arguments[0] === 'string' && typeof logger.debugSettings[_arguments[0]] !== 'undefined') {
      context = _arguments[0];
      thisArguments.shift();
    }
  }

  if (typeof logger.debugSettings[context] !== 'undefined' && logger.debugSettings[context]) {
    if (logger.canError) {
      // non-apply version for some browsers (*cough* ie)
      console.error(thisArguments);
    }
  }
};